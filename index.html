<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cem Öztürk</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Tinos:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

<style>
html,body{height:100%;margin:0}
body{
  font-family:"Tinos", serif;
  overflow-x:hidden;
  color:#fff;
  background:#111;
}

/* fixed background layers */
.bg{
  position:fixed;
  inset:0;
  z-index:-2;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
}
#bgA{ background-image:url("./assets/background.jpg"); opacity:1; }
#bgB{ background-image:url("./assets/events-bg.jpg"); opacity:0; }

/* overlays for readability */
.bgOverlayA,
.bgOverlayB{
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:-1;
}
.bgOverlayA{ background:rgba(245,243,238,0.25); }
.bgOverlayB{ background:rgba(0,0,0,0.25); opacity:0; }

main{ position:relative; }

/* sections */
.section{
  min-height:100vh;
  padding:40px;
  box-sizing:border-box;
  display:flex;
  align-items:flex-start;
}

/* HOME */
.hero{ margin-top:34px; }
.hero h1{
  margin:0;
  font-size:52px;
  letter-spacing:.04em;
  line-height:1;
  color:rgba(255,255,255,0.82);
  font-weight:400;
}
.hero p{
  margin:12px 0 0;
  font-size:18px;
  color:rgba(255,255,255,0.70);
  letter-spacing:.02em;

  display:flex;
  gap:6px;

  height:30px;
  align-items:center;
  line-height:30px;
  overflow:visible;
}
.word{
  display:inline-block;
  font-size:1em;
  line-height:1;
  white-space:nowrap;
  cursor:pointer;
  transform-origin:left center;
  transition:
    font-size 0.25s ease,
    letter-spacing 0.25s ease,
    color 0.25s ease,
    margin 0.25s ease;
}
.sep{ opacity:0.8; line-height:1; }
.word:hover{
  font-size:1.45em;
  letter-spacing:.04em;
  color:rgba(255,255,255,0.95);
  margin-right:6px;
}
.word a{ color:inherit; text-decoration:none; }
.word a:focus-visible{
  outline:1px solid rgba(255,255,255,0.6);
  outline-offset:4px;
}

/* SECTION HEADERS */
.sectionTitle{
  margin:0 0 18px 0;
  font-size:42px;
  letter-spacing:.04em;
  line-height:1;
  font-weight:400;
  color:rgba(255,255,255,0.82);
}

/* content wrapper */
.wrap{
  width:100%;
  max-width:1400px;
}

/* 4-column symmetrical grid */
.gallery{
  display:grid;
  grid-template-columns:repeat(4, 1fr);
  gap:24px;
}

/* Parallax + reveal system (composed transforms) */
.reveal{
  --revealY: 60px;
  --parX: 0px;
  --parY: 0px;

  opacity:0;
  transform: translate3d(var(--parX), calc(var(--revealY) + var(--parY)), 0);
  transition: opacity 650ms ease, transform 650ms ease;
  will-change: transform, opacity;
}
.reveal.is-visible{
  opacity:1;
  --revealY: 0px;
}

/* images stay honest */
.gallery img{
  width:100%;
  height:auto;
  display:block;
}

/* responsive */
@media (max-width: 1200px){
  .gallery{ grid-template-columns:repeat(3, 1fr); }
}
@media (max-width: 900px){
  .gallery{ grid-template-columns:repeat(2, 1fr); }
}
@media (max-width: 700px){
  .section{ padding:18px; }
  .hero h1{ font-size:40px; }
  .hero p{
    font-size:16px;
    height:26px;
    line-height:26px;
    padding-top:4px;
  }
}
@media (max-width: 500px){
  .gallery{ grid-template-columns:1fr; }
}

/* reduce motion */
@media (prefers-reduced-motion: reduce){
  .word{ transition:none; }
  .reveal{
    transition:none;
    opacity:1;
    --revealY:0px;
    --parX:0px;
    --parY:0px;
  }
}
</style>
</head>

<body>
  <!-- background layers -->
  <div id="bgA" class="bg" aria-hidden="true"></div>
  <div id="bgB" class="bg" aria-hidden="true"></div>
  <div class="bgOverlayA" aria-hidden="true"></div>
  <div id="overlayB" class="bgOverlayB" aria-hidden="true"></div>

  <main>
    <!-- HOME -->
    <section id="home" class="section">
      <div class="hero">
        <h1>CEM ÖZTÜRK</h1>
        <p>
          <span class="word"><a href="#designs">Designer</a></span>
          <span class="sep">,</span>
          <span class="word">researcher</span>
          <span class="sep">,</span>
          <span class="word"><a href="#events">event coordinator</a></span>
        </p>
      </div>
    </section>

    <!-- DESIGNS -->
    <section id="designs" class="section">
      <div class="wrap">
        <h2 class="sectionTitle">DESIGNS</h2>
        <div class="gallery">
          <img class="reveal" src="./assets/designer1.jpg" alt="Design 1">
          <img class="reveal" src="./assets/designer2.jpg" alt="Design 2">
          <img class="reveal" src="./assets/designer3.jpg" alt="Design 3">
          <img class="reveal" src="./assets/designer4.jpg" alt="Design 4">
          <img class="reveal" src="./assets/designer5.jpg" alt="Design 5">
        </div>
      </div>
    </section>

    <!-- EVENTS -->
    <section id="events" class="section">
      <div class="wrap">
        <h2 class="sectionTitle">EVENTS</h2>
        <div class="gallery">
          <img class="reveal" src="./assets/events1.jpg" alt="Event 1">
          <img class="reveal" src="./assets/events2.jpg" alt="Event 2">
          <img class="reveal" src="./assets/events3.jpg" alt="Event 3">
        </div>
      </div>
    </section>
  </main>

<script>
/* Smooth anchor scroll */
document.querySelectorAll('a[href^="#"]').forEach(a=>{
  a.addEventListener('click', (e)=>{
    const id = a.getAttribute('href');
    const el = document.querySelector(id);
    if(!el) return;
    e.preventDefault();
    el.scrollIntoView({behavior:'smooth', block:'start'});
  });
});

/* Background crossfade based on scroll position */
const bgB = document.getElementById('bgB');
const overlayB = document.getElementById('overlayB');

function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function smoothstep(edge0, edge1, x){
  const t = clamp01((x - edge0) / (edge1 - edge0));
  return t * t * (3 - 2 * t);
}

function updateBackgroundFade(){
  const home = document.getElementById('home');
  const designs = document.getElementById('designs');

  const homeRect = home.getBoundingClientRect();
  const designsRect = designs.getBoundingClientRect();

  const homeBottom = homeRect.bottom;

  // fully switched by mid-designs
  const designsMid = designsRect.top + (designs.offsetHeight * 0.5);

  const p = (0 - homeBottom) / (0 - designsMid);
  const t = clamp01(p);

  bgB.style.opacity = t.toFixed(3);
  overlayB.style.opacity = t.toFixed(3);
}

/* Reveal images on entry */
const revealEls = document.querySelectorAll('.reveal');
const io = new IntersectionObserver((entries)=>{
  entries.forEach(entry=>{
    if(entry.isIntersecting){
      entry.target.classList.add('is-visible');
      io.unobserve(entry.target);
    }
  });
}, { threshold: 0.15 });
revealEls.forEach(el => io.observe(el));

/* Aesthetic chaos parallax that snaps to alignment at a "sweet spot" */
function initParallaxChaos(){
  const imgs = Array.from(document.querySelectorAll('.gallery .reveal'));

  // Assign each image a unique parallax profile
  imgs.forEach((img, i) => {
    // speed: negative/positive mix, small enough to stay tasteful
    const speedY = ( (i % 7) - 3 ) * 0.06;         // -0.18 .. +0.18
    const speedX = ( (i % 5) - 2 ) * 0.03;         // -0.06 .. +0.06

    // base drift offsets for “chaos” (pixels)
    const baseX = ((i * 37) % 25) - 12;            // -12..+12
    const baseY = ((i * 53) % 35) - 17;            // -17..+17

    img.dataset.speedY = String(speedY);
    img.dataset.speedX = String(speedX);
    img.dataset.baseX = String(baseX);
    img.dataset.baseY = String(baseY);
  });

  function update(){
    const vh = window.innerHeight || 800;
    const sweetCenter = vh * 0.52;   // "sweet spot" around middle-ish
    const sweetRadius = vh * 0.28;   // how wide the calm zone is

    imgs.forEach((img) => {
      // If image isn't visible yet, don't bother animating it
      if (!img.classList.contains('is-visible')) return;

      const section = img.closest('.section');
      if (!section) return;

      // How close is this SECTION's center to the viewport center?
      const r = section.getBoundingClientRect();
      const sectionCenter = r.top + r.height * 0.5;

      const dist = Math.abs(sectionCenter - sweetCenter);

      // alignFactor: 1 near sweet spot (perfect alignment), 0 far away (chaos)
      const alignFactor = 1 - smoothstep(0, sweetRadius, dist);

      // chaosFactor is inverse
      const chaosFactor = 1 - alignFactor;

      // Parallax driven by scroll position, but scaled down
      const scrollY = window.scrollY || window.pageYOffset || 0;

      const speedY = parseFloat(img.dataset.speedY || "0");
      const speedX = parseFloat(img.dataset.speedX || "0");
      const baseX  = parseFloat(img.dataset.baseX  || "0");
      const baseY  = parseFloat(img.dataset.baseY  || "0");

      // Compute chaotic offsets
      const x = (baseX + scrollY * speedX) * chaosFactor;
      const y = (baseY + scrollY * speedY) * chaosFactor;

      img.style.setProperty('--parX', `${x.toFixed(2)}px`);
      img.style.setProperty('--parY', `${y.toFixed(2)}px`);
    });
  }

  // run on scroll/resize using rAF so it doesn't stutter
  let ticking = false;
  function onScroll(){
    if (ticking) return;
    ticking = true;
    requestAnimationFrame(() => {
      update();
      ticking = false;
    });
  }

  window.addEventListener('scroll', onScroll, {passive:true});
  window.addEventListener('resize', onScroll);
  update();
}

window.addEventListener('scroll', updateBackgroundFade, {passive:true});
window.addEventListener('resize', updateBackgroundFade);
updateBackgroundFade();

// start parallax system after initial paint
initParallaxChaos();
</script>
</body>
</html>
